{"codeFragments":[{"label":"PgpKeys properties","content":"private bool _toEncrypt; // true == for encryption, false == for decryption\r\n\r\n\t\tpublic PgpPublicKey PublicKey { get; set; }\r\n\t\tpublic PgpPrivateKey PrivateKey { get; set; }\r\n\t\tpublic PgpSecretKey SecretKey { get; set; }"},{"label":"PgpKeys constructor","content":"public PgpKeys(Stream publicKeyStream, Stream privateKeyStream = null, string passPhrase = null, bool toEncrypt = true)\r\n\t\t{\r\n\t\t\t_toEncrypt = toEncrypt;\r\n\t\t\tPublicKey = ReadPublicKey(publicKeyStream);\r\n\t\t\tif (privateKeyStream != null)\r\n\t\t\t{\r\n\t\t\t\tSecretKey = ReadSecretKey(privateKeyStream);\r\n\t\t\t\tPrivateKey = ReadPrivateKey(passPhrase);\r\n\t\t\t}\r\n\t\t}"},{"label":"PgpKeys get first public key","content":"private PgpPublicKey GetFirstPublicKey(PgpPublicKeyRingBundle publicKeyRingBundle)\r\n\t\t{\r\n\t\t\tforeach (PgpPublicKeyRing kRing in publicKeyRingBundle.GetKeyRings())\r\n\t\t\t{\r\n\t\t\t\tPgpPublicKey key = kRing.GetPublicKeys()\r\n\t\t\t\t\t.Cast<PgpPublicKey>()\r\n\t\t\t\t\t.FirstOrDefault(k => k.IsEncryptionKey);\r\n\t\t\t\tif (key != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn key;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}"},{"label":"PgpKeys get secret keys","content":"private PgpSecretKey GetFirstSecretKey(PgpSecretKeyRingBundle secretKeyRingBundle)\r\n\t\t{\r\n\t\t\tforeach (PgpSecretKeyRing kRing in secretKeyRingBundle.GetKeyRings())\r\n\t\t\t{\r\n\t\t\t\tPgpSecretKey key = kRing.GetSecretKeys()\r\n\t\t\t\t\t.Cast<PgpSecretKey>()\r\n\t\t\t\t\t.FirstOrDefault(k => k.IsSigningKey);\r\n\t\t\t\tif (key != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn key;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tprivate PgpSecretKey GetLastSecretKey(PgpSecretKeyRingBundle secretKeyRingBundle)\r\n\t\t{\r\n\t\t\treturn (from PgpSecretKeyRing kRing in secretKeyRingBundle.GetKeyRings()\r\n\t\t\t\t\tselect kRing.GetSecretKeys().Cast<PgpSecretKey>()\r\n\t\t\t\t\t.LastOrDefault(k => k.IsSigningKey))\r\n\t\t\t\t\t.LastOrDefault(key => key != null);\r\n\t\t}"},{"label":"PgpKeys read public","content":"private PgpPublicKey ReadPublicKey(Stream publicKeyStream)\r\n\t\t{\r\n\t\t\tusing (Stream inputStream = PgpUtilities.GetDecoderStream(publicKeyStream))\r\n\t\t\t{\r\n\t\t\t\tPgpPublicKeyRingBundle publicKeyRingBundle = new PgpPublicKeyRingBundle(inputStream);\r\n\t\t\t\tPgpPublicKey foundKey = GetFirstPublicKey(publicKeyRingBundle);\r\n\t\t\t\tif (foundKey != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn foundKey;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new ArgumentException(\"No encryption key found in public key ring.\");\r\n\t\t}"},{"label":"PgpKeys read private","content":"private PgpPrivateKey ReadPrivateKey(string passPhrase)\r\n\t\t{\r\n\t\t\tPgpPrivateKey privateKey = SecretKey.ExtractPrivateKey(passPhrase.ToCharArray());\r\n\t\t\tif (privateKey != null)\r\n\t\t\t{\r\n\t\t\t\treturn privateKey;\r\n\t\t\t}\r\n\t\t\tthrow new ArgumentException(\"No private key found in secret key.\");\r\n\t\t}"},{"label":"PgpKeys read secret","content":"private PgpSecretKey ReadSecretKey(Stream privateKeyStream)\r\n\t\t{\r\n\t\t\tusing (Stream inputStream = PgpUtilities.GetDecoderStream(privateKeyStream))\r\n\t\t\t{\r\n\t\t\t\tPgpSecretKeyRingBundle secretKeyRingBundle = new PgpSecretKeyRingBundle(inputStream);\r\n\t\t\t\tPgpSecretKey foundKey = GetFirstSecretKey(secretKeyRingBundle);\r\n\t\t\t\tif (foundKey != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn foundKey;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new ArgumentException(\"Can't find signing key in key ring.\");\r\n\t\t\t}\r\n\t\t}"},{"label":"Program console boilerplate","content":"string operation = null;\r\n            string source = null;\r\n            string destination = null;\r\n            if (args.Length < 1 || args.Length > 3) {\r\n                PrintUsage();\r\n                return;\r\n            }\r\n            else if (args.Length == 3) {\r\n                operation = args[0];\r\n                source = args[1];\r\n                destination = args[2];\r\n            }\r\n            else if (args.Length == 2) {\r\n                if (new[] { \"encrypt\", \"decrypt\" }.Any(x => x == args[0])) {\r\n                    operation = args[0];\r\n                    source = args[1];\r\n                }\r\n                else {\r\n                    source = args[0];\r\n                    destination = args[1];\r\n                }\r\n            }\r\n            else {\r\n                source = args[0];\r\n            }\r\n\r\n            operation = operation ?? \"encrypt\";\r\n            FileInfo sourceFile = new FileInfo(source);"},{"label":"Program get output stream ready","content":"Stream output = null;\r\n            if (destination == null) {\r\n                output = Console.OpenStandardOutput();\r\n            }\r\n            else {\r\n                FileInfo destFile = new FileInfo(destination);\r\n                output = destFile.OpenWrite();\r\n            }"},{"label":"Program read in PGP stuff","content":"FileInfo publicKey = new FileInfo(\"public.key\");\r\n            FileInfo privateKey = new FileInfo(\"private.key\");\r\n            PgpKeys keys = new PgpKeys(\r\n                publicKey.OpenRead(),\r\n                privateKey.OpenRead(),\r\n                Environment.GetEnvironmentVariable(\"PGP_PASSPHRASE\"),\r\n                operation == \"encrypt\"\r\n            );"},{"label":"Program get input stream ready","content":"Stream input = sourceFile.OpenRead();"},{"label":"Program encryption handler","content":"StreamEncryption encryptionHandler = new StreamEncryption(keys);\r\n            if (operation == \"encrypt\") {\r\n                encryptionHandler.Encrypt(sourceFile.Name, input, output);\r\n            }\r\n            else {\r\n                encryptionHandler.Decrypt(input, output);\r\n            }"},{"label":"Program clean up streams","content":"input.Close();\r\n            if (destination != null) {\r\n                output.Close();\r\n                FileInfo destFile = new FileInfo(destination);\r\n                Console.WriteLine($\"Output written to ${destFile.FullName}\");\r\n            }"},{"label":"Program main execution","content":"static void Main(string[] args)\r\n        {\r\n            // Console app boilerplate stuff to handle the args\r\n\r\n            // Get output stream ready, either file or stdout\r\n\r\n            Console.WriteLine($\"We will {operation.ToUpper()} the file {source} and output to {destination ?? \"stdout\"}\");\r\n\r\n            Console.WriteLine(\"Reading PGP keys ...\");\r\n            // Read in our PGP keys and passphrase\r\n\r\n            Console.WriteLine($\"Opening file at {sourceFile.FullName} ...\");\r\n            // Get input stream ready, read from file referenced by FileInfo\r\n\r\n            Console.WriteLine($\"Performing ${operation}ion operation and printing to output ...\");\r\n            // Construct our encryption handler and perform the desired operation\r\n\r\n            // Clean up streams neatly and finish execution\r\n        }"},{"label":"Program print instructions","content":"static void PrintUsage() {\r\n            Console.WriteLine(\"Usage: dotnet run [operation] <source> [destination]\");\r\n            Console.WriteLine();\r\n            Console.WriteLine(\"operation:  'encrypt' or 'decrypt' (defaults to encrypt)\");\r\n            Console.WriteLine(\"source:  path to source file\");\r\n            Console.WriteLine(\"destination:  path to output (defaults to stdout)\");\r\n        }"},{"label":"SE props and constructor","content":"private const int BUFFER = 0x10000; // 65536, an arbitrary power of 2\r\n\t\tprivate readonly PgpKeys _pgpKeys;\r\n\r\n\t\tpublic StreamEncryption(PgpKeys keys)\r\n\t\t{\r\n\t\t\tif (keys == null)\r\n\t\t\t{\r\n\t\t\t\tthrow new ArgumentNullException(\"keys\", \"keys object is null\");\r\n\t\t\t}\r\n\t\t\t_pgpKeys = keys;\r\n\t\t}"},{"label":"SE chain streams","content":"private Stream ChainEncryptedOut(Stream outputStream)\r\n\t\t{\r\n\t\t\tvar generator = new PgpEncryptedDataGenerator(SymmetricKeyAlgorithmTag.Aes256, true, new SecureRandom());\r\n\t\t\tgenerator.AddMethod(_pgpKeys.PublicKey);\r\n\t\t\treturn generator.Open(outputStream, new byte[BUFFER]);\r\n\t\t}\r\n\r\n\t\tprivate static Stream ChainLiteralOut(Stream encryptedOut, string fileName)\r\n\t\t{\r\n\t\t\tvar generator = new PgpLiteralDataGenerator();\r\n\t\t\t// fileName is just a data point, but some implementations check it for validation\r\n\t\t\treturn generator.Open(encryptedOut, PgpLiteralData.Utf8, fileName, DateTime.Now, new byte[BUFFER]);\r\n\t\t}"},{"label":"SE Decrypt Load input streams","content":"var input = PgpUtilities.GetDecoderStream(inputStream);\r\n\t\t\tvar encryptedFactory = new PgpObjectFactory(input);\r\n\t\t\tPgpEncryptedDataList dataList;"},{"label":"SE Decrypt Iterate until we hit the first PgpEncryptedDataList","content":"PgpObject obj;\r\n\t\t\tdo {\r\n\t\t\t\tobj = encryptedFactory.NextPgpObject();\r\n\t\t\t} while (!(obj is PgpEncryptedDataList));\r\n\t\t\tdataList = (PgpEncryptedDataList)obj;"},{"label":"SE Decrypt Use our private key","content":"PgpPublicKeyEncryptedData encryptedData =\r\n\t\t\t\tdataList.GetEncryptedDataObjects().Cast<PgpPublicKeyEncryptedData>().First();\r\n\t\t\tStream decryptedData = encryptedData.GetDataStream(_pgpKeys.PrivateKey);\r\n\t\t\tvar decryptedFactory = new PgpObjectFactory(decryptedData);\r\n\r\n\t\t\tPgpObject message = decryptedFactory.NextPgpObject();"},{"label":"SE Decrypt If the message starts with a signature","content":"if (message is PgpOnePassSignatureList)\r\n\t\t\t{\r\n\t\t\t\tmessage = decryptedFactory.NextPgpObject();\r\n\t\t\t}\r\n\t\t\tPgpLiteralData literalData = (PgpLiteralData)message;"},{"label":"SE Decrypt Pipe the literal data","content":"Stream decryptedLiteral = literalData.GetInputStream();\r\n\t\t\tStreams.PipeAll(decryptedLiteral, outputStream);"},{"label":"SE Decrypt method shell","content":"public void Decrypt(Stream inputStream, Stream outputStream)\r\n\t\t{\r\n\t\t\t// Load input stream into PgpEncryptedDataList\r\n\r\n\t\t\t// Iterate until we hit the first PgpEncryptedDataList\r\n\r\n\t\t\t// Use our private key to decrypt\r\n\r\n\t\t\t// If the message starts with a signature, jump to the next object\r\n\r\n\t\t\t// Pipe the literal data to our output stream\r\n\t\t}"},{"label":"SE Encrypt Encrypted stream outer layer","content":"Stream encryptedOut = ChainEncryptedOut(outputStream);\r\n\t\t\tif (sign)\r\n\t\t\t{\r\n\t\t\t\tsignatureGenerator = InitSignatureGenerator(encryptedOut);\r\n\t\t\t}"},{"label":"SE Encrypt Literal stream is inner layer","content":"Stream literalOut = ChainLiteralOut(encryptedOut, fileName);\r\n\t\t\tint length = 0;\r\n\t\t\tbyte[] buffer = new byte[BUFFER];"},{"label":"SE Encrypt Standard NET stream stuff","content":"while ((length = inputStream.Read(buffer, 0, buffer.Length)) > 0)\r\n\t\t\t{\r\n\t\t\t\tliteralOut.Write(buffer, 0, length);\r\n\t\t\t\tif (sign)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Keep the signature generator in sync\r\n\t\t\t\t\tsignatureGenerator.Update(buffer, 0, length);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tliteralOut.Close();\r\n\r\n\t\t\tif (sign)\r\n\t\t\t{\r\n\t\t\t\t// Generate and apply the signature to the outer stream at the end\r\n\t\t\t\tsignatureGenerator.Generate().Encode(encryptedOut);\r\n\t\t\t}\r\n\t\t\tencryptedOut.Close();"},{"label":"SE Encrypt method shell","content":"public void Encrypt(string fileName, Stream inputStream, Stream outputStream, bool sign = false)\r\n\t\t{\r\n\t\t\t// Init this to null so the IDE doesn't give us warnings\r\n\t\t\tPgpSignatureGenerator signatureGenerator = null;\r\n\r\n\t\t\t// Encrypted stream is the outer layer, gets fed to the output stream\r\n\r\n\t\t\t// Literal stream is the inner layer, gets fed to the encrypted stream\r\n\r\n\t\t\t// Standard .NET stream reading/writing stuff\r\n\t\t}"},{"label":"SE PgpSigGen Get our generator set up","content":"PublicKeyAlgorithmTag tag = _pgpKeys.SecretKey.PublicKey.Algorithm;\r\n\t\t\tvar pgpSignatureGenerator = new PgpSignatureGenerator(tag, HashAlgorithmTag.Sha1);\r\n\t\t\tpgpSignatureGenerator.InitSign(PgpSignature.BinaryDocument, _pgpKeys.PrivateKey);"},{"label":"SE PgpSigGen Get the user identity","content":"var userIds = _pgpKeys.SecretKey.PublicKey.GetUserIds().OfType<string>();\r\n\t\t\tstring userId = userIds.FirstOrDefault();\r\n\t\t\tif (userId != null)\r\n\t\t\t{\r\n\t\t\t\tvar subPacketGenerator = new PgpSignatureSubpacketGenerator();\r\n\t\t\t\tsubPacketGenerator.SetSignerUserId(isCritical: false, userId: userId);\r\n\t\t\t\tpgpSignatureGenerator.SetHashedSubpackets(subPacketGenerator.Generate());\r\n\t\t\t}"},{"label":"SE PgpSigGen Kick things off","content":"pgpSignatureGenerator.GenerateOnePassVersion(isNested: false).Encode(streamToSign);\r\n\t\t\treturn pgpSignatureGenerator;"},{"label":"SE PgpSigGen method shell","content":"private PgpSignatureGenerator InitSignatureGenerator(Stream streamToSign)\r\n\t\t{\r\n\t\t\t// Get our generator set up to match our keys\r\n\r\n\t\t\t// Get the user identity from our secret key and use it for signing\r\n\r\n\t\t\t// Kick things off and send the generator back to caller for the rest\r\n\t\t}"}]}